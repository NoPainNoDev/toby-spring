#제어의 역전 IoC(Inversion of Control)

제어의 역전 패턴은 'GoF 디자인 패턴' 책에서도 찾아볼 수 있다.
제어의 역전이 무엇인지 살펴보고 코드를 개선해보자.

## 1.4.1 오브젝트 팩토리
UserDaoTest는 ConnectionMaker 구현 클래스 사용을 결정하는 기능을 얼떨결에 떠맡고 있었다.
UserDao가 ConnectionMaker로 부터 완벽히 독립할 수 있게 UserDaoTest가 그 수고를 담당하게 된 것이다.
하지만 UserDaoTest는 테스트하려고 만든것이니, 또 다른 책임을 떠맡고 있으니 뭔가 문제가 있다.
그러니 이것도 분리해야 한다. 
즉, UserDao와 ConnectionMaker구현 클래스 두 개의 오브젝트가 연결돼서 사용될 수 있게 관계를 맺어주는 관심을 분리해야 한다.

### 팩토리(factory) 
1. 객체의 생성방법 결정
2. 생성한 오브젝트를 돌려줌

(앞서나온 추상 팩토리 패턴, 메소드 팩토리 패턴과는 다르니, 혼동하지 말자)

UserDao의 생성 책임을 맡은 팩토리 클래스
==========================================================================================
package springbook.user.dao;
...
public class DaoFactory {
    public UserDao userDao() {
        // 팩토리 메소드는 UserDao 타입의 오브젝트를 어떻게 만들고, 어떻게 준비시킬지 결정한다.
        ConnectionMaker connectionMaker = new DConnectionMaker();   
        UserDao userDao = new UserDao(connectionMaker);
        return userDao;
    }
}
==========================================================================================

팩토리를 사용하도록 수정한 UserDaoTest
==========================================================================================
public class UserDaoTest {
    public static void main(String[] args) throws ClassNotFoundException,
        SQLException {
            UserDao dao = new DaoFactory.userDao();
            ...
        }
}
==========================================================================================

### 설계도로서의 팩토리
분리된 오브젝트들의 역할과 관계를 분석하면 다음과 같다.

* UserDao와 ConnectionMaker --> 각각 애플리케이션의 핵심적인 데이터 로직, 기술 로직을 담당 (컴포넌트)
* DaoFactory --> 애플리케이션의 오브젝트들을 구성, 관계 정의 (컴포넌트들의 관계를 정의하는 설계도)

(여기서의 설계도 : 어떤 오브젝트가 어떤 오브젝트를 사용하는지 정의해놓은 코드)


* 오브젝트 팩토리를 활용한 구조
(컴포넌트)     Client --(사용)--> UserDao --(사용)--> ConnectionMaker
                                  ↑                     ↑
                                (생성)                   ↑
                                  ↑              DConnectionMaker
(설계도)                                                  ↑
                    -(요청)-> DaoFactory --(생성)-->      ↑

이제 코드의 수정이 일어나는 경우 DaoFactory를 수정해주면된다.
UserDao는 변경이 필요 없으므로 안전하게 소스코드를 보존할 수 있는 동시에 DB 연결 방식을 자유롭게 확장이 가능하다.

Factory를 분리했을 때 얻을 수 있는 장점을 매우 다양하다.
그중에서도 컴포넌트 역할을 하는 오브젝트와 구조를 결정하는 오브젝트를 분리했다는 데 가장 의미가 있다.

(컴포넌트 오브젝트) <------ (구조결정 오브젝트)


## 1.4.2 오브젝트 팩토리의 활용
현재 팩토리 구조에서 AccountDao, MessageDao 와 같은 DAO 클래스를 만들면 어떻게 될까?
accountDao(), messageDao() 와 같이 매번 메소드를 만들어줘야 할것이다.
이는 어떤 ConnectionMaker 구현 클래스를 사용할지 결정하는 기능의 중복을 초래한다.

DAO 생성 메소드의 추가 발생하는 중복
==========================================================================================
public class DaoFactory {
    public UserDao userDao() {
        return new UserDao(new DConnectionMaker());     // 중복
    }

    public AccountDao accountDao() {
        return new AccountDao(new DConnectionMaker);    // 중복
    }

    public MessageDao messageDao() {
        return new MessageDao(new DConnectionMaker);    // 중복
    }
}
==========================================================================================

중복문제를 해결하려면 분리하는 것이 최선의 방법이다.
ConnectionMaker의 구현 클래스를 결정하고 오브젝트를 만드는 코드를 메소드화한다.

생성 오브젝트 코드 수정
==========================================================================================
public class DaoFactory {
    public UserDao userDao() {
        return new UserDao(connectionMaker());    
    }

    public AccountDao accountDao() {
        return new AccountDao(connectionMaker());    
    }

    public MessageDao messageDao() {
        return new MessageDao(connectionMaker());    
    }

    public ConnectionMaker connectionMaker() {
        return new DConnectionMaker();
    }
}
==========================================================================================


## 1.4.3 제어권의 이전을 통한 제어관계 역전
제어역전 --> 프로그램의 제어 흐름 구조가 뒤바뀌는 것
제어의역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지도 않을 뿐더러, 생성하지도 않는다.
또한 어떻게 만들어지고 어디서 사용되는지를 알 수 없다. 모든 권한을 다른 대상에게 위임하기 때문이다.

사실 제어의역전은 이미 폭넓게 사용되고 있다. 서블릿을 예로 들 수 있겠다.
서블릿은 개발하여 서버에 배포는 가능하지만, 그 실행을 개발자가 직접 제어할 수 있는 방법은 없다.
서블릿의 제어 권한을 가진 컨테이너가 적절한 시점에 클래스의 오브젝트를 만들고 그 안의 메소드를 호출한다.
이처럼 서블릿, JSP, EJB 등은 컨테이너 안에서 동작방식은 간단하지만 제어의역전 개념이 적용되어 있다.

이전에 살펴본 템플릿 메소드 패턴에서도 제어의역전을 찾아볼 수 있다. 
슈퍼클래스인 UserDao가 커넥션을 만들어 놓으면, 서브 클래스에서 해당 커넥션을 사용하는 구조가 제어의역전이다.
템플릿 메소드 패턴은 제어의역전을 이용해 문제를 해결하는 패턴인 샘이다.

프레임웤크도 제어의역전이 적용된 대표적인 기술이다. 프레임워크는 라이브러리와 같은 개념이라 볼 수 있다.
다만, 프레임워크는 미리 만들어놓은 반제품이다. 라이브러리처럼 확장하여 사용할 수 있게 준비되지 않았다.
프레임워크와 라이브러리의 차이점이 여기서 생기는 것이다. 
라이브러리를 사용하는 코드는 애플리케이션 흐름을 직접 제어한다. 
단지 동작하는 중에 필요한 기능이 있을때 능동적으로 라이브러리를 사용할 뿐이다.
반면에 프레임워크는 코드가 프레임워크에 의해 사용된다. 보통 프레임워크 위에 개발한 클래스를 등록해두고,
프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식이다.

최근에는 툴킷, 엔진, 라이브러리에도 무작정 프레임워크라고 부르기도 하는데 이는 잘못된 것이다.
프레임워크에는 분명한 제어의역전 개념이 적용되어 있어야 한다. 코드는 프레임워크가 짜놓은 틀에서 수동적으로 동작해야 한다.

UserDao와 DaoFactory에도 제어의 역전이 적용되어 있다.
원래 ConnectionMaker의 구현 클래스를 결정하고 오브젝트를 만드는 제어권은 UserDao에게 있었다.
하지만 지금은 DaoFactory에게 있다. 모든 권한을 DaoFactory에 넘겼으니 UserDao는 이제 수동적인 존재가 되었다.
UserDao 자신도 수동적으로 만들어지고 자신이 사용할 오브젝트도 팩토리를 통해 공급해주는 것을 수동적으로 사용해야한다.
바로 이것이 제어의역전(IoC)이 일어난 상황이다. 
자연스럽게 관심을 분리하고 책임을 나누고 유연하게 확장 가능한 구조를 만들기 위해 팩토리를 도입했던 과정이 바로 IoC를 적용하는 작업이었다 볼 수 있다.

IoC는 단지 프레임워크만의 기술도 아니고 꼭 프레임워크에서만 필요한 개념도 아니다.
디자인패턴에서도 발견할 수 있는 것처럼 폭넓게 사용되는 프로그래밍 모델이다.
IoC를 적용함으로써 설계가 깔끔해지고 유연성이 증가하며 확장성이 좋아지기 때문에 필요할 때면 IoC 스타일 설계와 코드를 만들어 사용하면 된다. 

제어의역전에서는 프레임워크 또는 컨테이너와 같이 애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 관리 등을 관장하는 존재가 필요하다.
DaoFactory는 오브젝트 수준의 가장 단순인 IoC 컨테이너 내지는 IoC 프레임워크라 불릴 수 있다.
IoC를 애플리케이션 전반에 걸쳐 본격적으로 사용하기 위해서는 스프링과 같은 IoC 프레임워크의 도움을 받아야 한다.
스프링은 IoC를 모든 기능의 기초가 되는 기반기술로 삼고 있으며, IoC를 극한까지 적용하고 있는 프레임워크이다.
이제 본격적으로 스프링에서 제공하는 IoC에 대해 살펴보도록 하자.